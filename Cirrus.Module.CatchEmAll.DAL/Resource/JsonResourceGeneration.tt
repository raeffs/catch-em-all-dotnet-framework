<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Reflection" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>

<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#

var dte = default(DTE);
var serviceProvider = Host as IServiceProvider;

if (serviceProvider != null) 
{
    dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
}

if (dte == null) 
{
    throw new Exception("T4MVC can only execute through the Visual Studio host");
}

var project = GetProjectContainingT4File(dte);

if (project == null) 
{
    throw new Exception("Could not find the VS Project containing the T4 file");
}
    
var appRoot = Path.GetDirectoryName(project.FullName) + '\\';
var rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();
var resourceFileNameProvider  = CreateResourceFileNameProvider(appRoot);

#>
// <auto-generated />
using Cirrus.Localisation;

namespace <#= rootNamespace#>
{

	public class ResourceFileNameProvider : Cirrus.Localisation.Resource.ResourceFileNameProvider 
	{
	}
<#
var allEntries = new List<ResourceEntry>();
FindResourceFilesRecursivlyAndRecordEntries(resourceFileNameProvider, project.ProjectItems, "ResourceFiles", allEntries);
allEntries.Sort(new Comparison<ResourceEntry>( (e1, e2) => (e1.Path + e1.File + e1.Name).CompareTo(e2.Path + e2.File + e2.Name)));

var currentClass = string.Empty;

#>

<#
foreach(var entry in allEntries)
{
    var newClass = entry.File;
    var classIsChanging = newClass != currentClass;
    
    var module = rootNamespace.Split('.')[2];
	var io = new List<string> { module };
	io.AddRange(entry.Path.Split('.').Skip(2).ToList());

	var prefix = string.Join("_", io);
    //Close out current class if class is changing and there is a current class
    if(classIsChanging && currentClass != "")
    {
        #>

    }

        <#
    }

    if (classIsChanging)
    {
        currentClass = newClass;
        #>

    internal class <#= currentClass #> : Cirrus.Localisation.<#= currentClass #>
    {
		<#
    } // classIsChanging
    #>
<# if(entry.Name.IndexOf('.') == -1) { #>

<# if(currentClass == "DisplayActions") { #>
		public static IDisplayAction <#= prefix #>_<#= entry.Name #> { get; } = new DisplayAction("<#= prefix #>_<#= entry.Name #>"); <# 
	} else {#>
		public static ITranslationItem <#= prefix #>_<#= entry.Name #> { get; } = new TranslationItem("<#= prefix #>_<#= entry.Name #>", "<#= currentClass #>");<#
	}#>
<#}#>
    <#
} // foreach
    
//close out the current class when donef
if(currentClass != "")
{
#>

    }

<#
}
#>
}
#pragma warning restore
<#+

const string Kind_PhysicalFolder = "{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}";
    
void FindResourceFilesRecursivlyAndRecordEntries(object resourceFileNameProvider, ProjectItems items, string path, List<ResourceEntry> all)
{
    foreach(ProjectItem item in items)
    {
        if(Path.GetExtension(item.Name) == ".json")
            RecordEntriesInResourceFile(resourceFileNameProvider, item, path, all);
        if(item.Kind == Kind_PhysicalFolder)
            FindResourceFilesRecursivlyAndRecordEntries(resourceFileNameProvider, item.ProjectItems, path + "." + item.Name, all);
    }
}

void RecordEntriesInResourceFile(object resourceFileNameProvider, ProjectItem item, string path, List<ResourceEntry> all)
{
    //skip resource files except those for the default culture
    if (Regex.IsMatch(item.Name, @".*\.[a-zA-z]{2}(-[a-zA-z]{2})?\.json"))
        return;
	
	if(item.Name.Contains("_"))
		return;

    var filePath = (string)item.Properties.Item("FullPath").Value;
	
	var str = File.ReadAllText(filePath);
	
	try{
		var entries = GetEntries(resourceFileNameProvider, str);
		if(entries == null)
			return;
    

		var parentFile = item.Name.Replace(".json", "");
		var fileType = Path.GetExtension(parentFile);
		if(fileType != null && fileType != "")
			parentFile = parentFile.Replace(fileType, "");

		foreach (var entryElement in entries)
		{
			var entry = new ResourceEntry
			{
				Path = path.Substring(1),
				File = MakeIntoValidIdentifier(parentFile),
				Type = fileType,
				Name = MakeIntoValidIdentifier(entryElement.Name)
			};
			var valueElement = entryElement.Value;
			var commentElement = entryElement.Comment;
        
			all.Add(entry);
		}
	} catch(Exception e) {
		Console.WriteLine(e);
		throw;
	}
}

dynamic GetEntries(object resourceFileNameProvider, string file) {
    var method = resourceFileNameProvider.GetType().GetMethod("FromFile");
    var returnValue = method.Invoke(resourceFileNameProvider, new object[] { file });
    return returnValue;
}


object CreateResourceFileNameProvider(string appRoot) {
    var assemblyNameToFileMapping = new Dictionary<string, string>();
	
	foreach (string f in Directory.EnumerateFiles(appRoot+@"bin\Debug\", "*.dll"))
    {
        try
        {
            var name = System.Reflection.AssemblyName.GetAssemblyName(f);
            assemblyNameToFileMapping.Add(name.FullName.Split(',')[0], f);
        }
        catch
        {
        }
    }

	AppDomain.CurrentDomain.AssemblyResolve += (object sender, ResolveEventArgs args) => {
        string f;
        if (assemblyNameToFileMapping.TryGetValue(args.Name.Split(',')[0], out f))
        {
            return System.Reflection.Assembly.LoadFrom(f);
        }
        return null;
    };

	var file = appRoot+@"bin\Debug\Cirrus.Core.Localisation.dll";
    var assembly = System.Reflection.Assembly.LoadFile(file);
    var type = assembly.GetType("Cirrus.Localisation.Resource.ResourceFileNameProvider");
    var instance = System.Activator.CreateInstance(type);
	return instance;
}

string MakeIntoValidIdentifier(string arbitraryString)
{
    var validIdentifier = Regex.Replace(arbitraryString, @"[^A-Za-z0-9-._]", " ");
    //validIdentifier = ConvertToPascalCase(validIdentifier);
    if (Regex.IsMatch(validIdentifier, @"^\d")) validIdentifier = "_" + validIdentifier;
    return validIdentifier;
}

string ConvertToPascalCase(string phrase)
{
    string[] splittedPhrase = phrase.Split(' ', '-', '.');
    var sb = new StringBuilder();

    sb = new StringBuilder();

    foreach (String s in splittedPhrase)
    {
        char[] splittedPhraseChars = s.ToCharArray();
        if (splittedPhraseChars.Length > 0)
        {
            splittedPhraseChars[0] = ((new String(splittedPhraseChars[0], 1)).ToUpper().ToCharArray())[0];
        }
        sb.Append(new String(splittedPhraseChars));
    }
    return sb.ToString();
}

struct ResourceEntry
{
    public string Path { get; set; }
    public string File { get; set; }
    public string Type { get; set; }
    public string Name { get; set; }
    public string Value { get; set; }
    public string Comment { get; set; }
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    // projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

#>